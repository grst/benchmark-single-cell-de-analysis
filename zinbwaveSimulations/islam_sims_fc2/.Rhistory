rownames(df) = NULL
kable(df)
trueDE = rep(0, nTags)
trueDE[simDataIslam$indDE] = 1
#all methods
pp = COBRAData(pval = as.data.frame(do.call(cbind, lapply(res, '[[', 1))),
padj = as.data.frame(do.call(cbind, lapply(res, '[[', 2))),
truth = data.frame(status = trueDE))
cobraperf <- calculate_performance(pp, binary_truth = "status", thrs = 0.05)
colors=c(limmavoom="blue", "ZINB-WaVE_limmavoom_common"="steelblue", "ZINB-WaVE_limmavoom_genewise"="darkslategray3", edgeR="red", "ZINB-WaVE_edgeR_common"="salmon", "ZINB-WaVE_edgeR_genewise"="deeppink2",  DESeq2="brown",  "ZINB-WaVE_DESeq2_common"="darkseagreen", "ZINB-WaVE_DESeq2_genewise"="darkkhaki",  MAST="darkturquoise", metagenomeSeq="forestgreen", scde="grey", NODES="black",  Seurat="dodgerblue", "zingeR_edgeR"="hotpink1", zingeR_DESeq2="darkolivegreen4")
#iCOBRA converts '-' to '.'. Redo this.
cobraNames = sort(names(cobraperf@overlap)[1:(ncol(cobraperf@overlap)-1)])
cobraNames = gsub(x=cobraNames, pattern=".", fixed=TRUE, replacement="-")
colsCobra=colors[match(cobraNames,names(colors))]
cobraplot <- prepare_data_for_plot(cobraperf, colorscheme=colsCobra)
save(cobraplot,file="cobraPlotIslamAllMethods.rda")
plot_fdrtprcurve(cobraplot, pointsize=1)
#only common disp ZINB-WaVE
pvalDf = as.data.frame(do.call(cbind, lapply(res, '[[', 1)))
padjDf = as.data.frame(do.call(cbind, lapply(res, '[[', 2)))
pvalDfCommon = pvalDf[,-grep(x=colnames(pvalDf), pattern="genewise")]
padjDfCommon = padjDf[,-grep(x=colnames(padjDf), pattern="genewise")]
pp = COBRAData(pval = pvalDfCommon,
padj = padjDfCommon,
truth = data.frame(status = trueDE))
cobraperf <- calculate_performance(pp, binary_truth = "status", thrs = 0.05)
colors=c(limmavoom="blue", "ZINB-WaVE_limmavoom_common"="steelblue", "ZINB-WaVE_limmavoom_genewise"="darkslategray3", edgeR="red", "ZINB-WaVE_edgeR_common"="salmon", "ZINB-WaVE_edgeR_genewise"="deeppink2",  DESeq2="brown",  "ZINB-WaVE_DESeq2_common"="darkseagreen", "ZINB-WaVE_DESeq2_genewise"="darkkhaki",  MAST="darkturquoise", metagenomeSeq="forestgreen", scde="grey", NODES="black",  Seurat="dodgerblue", "zingeR_edgeR"="hotpink1", zingeR_DESeq2="darkolivegreen4")
#iCOBRA converts '-' to '.'. Redo this.
cobraNames = sort(names(cobraperf@overlap)[1:(ncol(cobraperf@overlap)-1)])
cobraNames = gsub(x=cobraNames, pattern=".", fixed=TRUE, replacement="-")
colsCobra=colors[match(cobraNames,names(colors))]
cobraplot <- prepare_data_for_plot(cobraperf, colorscheme=colsCobra)
save(cobraplot,file="cobraplotIslam.rda")
plot_fdrtprcurve(cobraplot, pointsize=1)
#only common disp ZINB-WaVE, no ZINB-WaVE_limma-voom
pvalDfCommon2 = pvalDfCommon[,-grep(x=colnames(pvalDfCommon), pattern="ZINB-WaVE_limmavoom")]
padjDfCommon2 = padjDfCommon[,-grep(x=colnames(padjDfCommon), pattern="ZINB-WaVE_limmavoom")]
pp = COBRAData(pval = pvalDfCommon2,
padj = padjDfCommon2,
truth = data.frame(status = trueDE))
cobraperf <- calculate_performance(pp, binary_truth = "status", thrs = 0.05)
colors=c(limmavoom="blue", "ZINB-WaVE_limmavoom_common"="steelblue", "ZINB-WaVE_limmavoom_genewise"="darkslategray3", edgeR="red", "ZINB-WaVE_edgeR_common"="salmon", "ZINB-WaVE_edgeR_genewise"="deeppink2",  DESeq2="brown",  "ZINB-WaVE_DESeq2_common"="darkseagreen", "ZINB-WaVE_DESeq2_genewise"="darkkhaki",  MAST="darkturquoise", metagenomeSeq="forestgreen", scde="grey", NODES="black",  Seurat="dodgerblue", "zingeR_edgeR"="hotpink1", zingeR_DESeq2="darkolivegreen4")
#iCOBRA converts '-' to '.'. Redo this.
cobraNames = sort(names(cobraperf@overlap)[1:(ncol(cobraperf@overlap)-1)])
cobraNames = gsub(x=cobraNames, pattern=".", fixed=TRUE, replacement="-")
colsCobra=colors[match(cobraNames,names(colors))]
cobraplot <- prepare_data_for_plot(cobraperf, colorscheme=colsCobra)
#save(cobraplot,file="cobraplotIslamNoLimma.rda")
plot_fdrtprcurve(cobraplot, pointsize=1) +xlab("FDP")
# res10 = res[1:10]
# names(res10) = gsub('_common', '', names(res10))
# pp = COBRAData(pval = as.data.frame(do.call(cbind, lapply(res10, '[[', 1))),
#                padj = as.data.frame(do.call(cbind, lapply(res10, '[[', 2))),
#                truth = data.frame(status = trueDE))
# cobraperf <- calculate_performance(pp, binary_truth = "status", thrs = 0.05)
#
# reds = brewer.pal(11, "RdYlGn")[1:3]
# blues = rev(brewer.pal(11, "RdYlBu"))[1:3]
# brown =  brewer.pal(8, "Dark2")[4]
# greens = rev(brewer.pal(11, "PiYG"))[1:3]
# mycol = c(blues[1], greens[1], reds[1], brown, blues[2], greens[2], reds[2],
#           blues[3], greens[3], reds[3], 'black')
# names(mycol) = c(names(res10), 'truth')
# names(cobraperf@overlap) = names(mycol)
# colsCobra <- mycol[match(sort(names(cobraperf@overlap)[1:(ncol(cobraperf@overlap)-1)]), names(mycol))]
# cobraplot <- prepare_data_for_plot(cobraperf, colorscheme = colsCobra,
#                                    facetted = FALSE)
#
# p1 <- plot_fdrtprcurve(cobraplot, plottype = c("curve", "points"), pointsize = 1,
#                        linewidth = .5, xaxisrange = c(0, .5)) +
#   theme(axis.text.x = element_text(size = 10),
#         axis.text.y = element_text(size = 10),
#         axis.title.x = element_text(size = 15),
#         axis.title.y = element_text(size = 15),
#         legend.text=element_text(size=7)) + theme(legend.position="none")
#
# orderLegend = c(2, 9, 6, 1, 8, 5, 3, 10, 7, 4)
# p2 <- plot_fdrtprcurve(cobraplot, plottype = c("curve", "points"), pointsize = 1,
#                        linewidth = .5, xaxisrange = c(0, .5)) +
#   theme(legend.text=element_text(size=7)) +
#   scale_color_manual(labels = names(colsCobra)[orderLegend],
#                      values = unname(colsCobra)[orderLegend],
#                      name = 'Method')
# legend <- get_legend(p2)
#
# #pdf("../../draftOverleaf/10963157vrrwqjqjdrnf/performanceIslamfc2.pdf")
# plot_grid(p1, legend, nrow = 1, ncol = 2, rel_widths = c(1, .4))
# #dev.off()
# setwd("/Users/koenvandenberge/Dropbox/phdKoen/singleCell/zinbwaveZingerGithub/zinbwaveZinger/zinbwaveSimulations/islam_sims_fc2/")
knitr::opts_chunk$set(fig.align="center", cache=TRUE, error=FALSE, message=FALSE, warning=TRUE)
library(reticulate)
library(zinbwave)
library(BiocParallel)
library(doParallel)
library(Biobase)
library(edgeR)
library(scales)
library(DESeq2)
library(iCOBRA) # roc
library(limma)
library(genefilter) #filtered pvalues
library(MAST)
library(RColorBrewer)
library(knitr)
library(ggplot2)
library(cowplot)
# use new simulation.
#library(zingeR)
# pathToParentFolder="~/Dropbox/phdKoen/singleCell/zinbwavezingerGitHub/zinbwaveZinger/"
source("../../zingeRsimulationFunctions/simulationHelpFunctions_v7_diffInZero.R")
knitr::knit_engines$set(python = reticulate::eng_python)
reticulate::py_available(TRUE)
# bug in rstudio/reticulate:
matplotlib <- import("matplotlib")
matplotlib$use("Agg", force = TRUE)
NCORES <- 8
registerDoParallel(NCORES)
register(DoparParam())
#code from https://github.com/statOmics/zingeR/blob/master/vignettes/zingeRVignette_v2.Rmd
data(islamEset, package = "zingeR")
islamHlp=exprs(islamEset)[9:nrow(exprs(islamEset)),] #first 8 are spike-ins.
cellType=pData(islamEset)[,"cellType"]
# paramsIslam = getDatasetMoMPositive(counts = islamHlp)
# save(paramsIslam, file="./paramsIslam.rda")
load("./paramsIslam.rda")
nSamples=80
grp=as.factor(rep(0:1, each = nSamples/2)) #two-group comparison
nTags=10000 #nr of features
set.seed(11)
DEind = sample(1:nTags,floor(nTags*.1),replace=FALSE) #10% DE
fcSim=(2 + rexp(length(DEind), rate = 1/2)) #fold changes
libSizes=sample(colSums(islamHlp),nSamples,replace=TRUE) #library sizes
simDataIslam <- NBsimSingleCell(foldDiff = fcSim, ind = DEind,
dataset = islamHlp, nTags = nTags,
group = grp,
verbose = TRUE, params = paramsIslam,
lib.size = libSizes, normalizeLambda=TRUE)
simDataIslam$counts[1:5,1:5]
# BCV plots
dOrig=suppressWarnings(edgeR::calcNormFactors(DGEList(islamHlp)))
dOrig=estimateGLMTagwiseDisp(estimateGLMCommonDisp(dOrig, design=model.matrix(~cellType), interval=c(0,10)),prior.df=0)
d=suppressWarnings(edgeR::calcNormFactors(DGEList(simDataIslam$counts)))
d=estimateGLMTagwiseDisp(estimateGLMCommonDisp(d, design=model.matrix(~grp), interval=c(0,10)),prior.df=0)
par(mfrow=c(1,2))
plotBCV(dOrig,ylim=c(0,13), xlim=c(2,16), main="real dataset")
plotBCV(d,ylim=c(0,13), xlim=c(2,16), main="simulated dataset")
par(mfrow=c(1,1))
# association of library size with zeros
plot(x=colSums(islamHlp), y=colMeans(islamHlp==0), xlab="Log library size", ylab="Fraction of zeros", ylim=c(0.2,1))
points(x=colSums(simDataIslam$counts), y=colMeans(simDataIslam$counts==0), col=2)
legend("bottomleft", c("real", "simulated"), col=1:2, pch=1)
# association of aveLogCPM with zeros
plot(x=edgeR::aveLogCPM(islamHlp), y=rowMeans(islamHlp==0), xlab="Average log CPM", ylab="Fraction of zeros", ylim=c(0,1), col=alpha(1,1/2), pch=19, cex=.3)
points(x=edgeR::aveLogCPM(simDataIslam$counts), y=rowMeans(simDataIslam$counts==0),col=alpha(2,1/2),pch=19,cex=.3)
legend("bottomleft", c("real", "simulated"), col=1:2, pch=16)
diffxpy_wald = function(counts, group, ylim = NULL, xlim=NULL) {
res = py$wald_test(counts, group)
}
core <- SummarizedExperiment(simDataIslam$counts,
colData = data.frame(grp = grp))
# zinb_c <- zinbFit(core, X = '~ grp', commondispersion = TRUE, epsilon=1e12)
# save(zinb_c, file = 'zinb-common-disp-fc2-eps12.rda')
load('zinb-common-disp-fc2-eps12.rda')
# zinb_g <- zinbFit(core, X = '~ grp', commondispersion = FALSE, epsilon=1e12)
# save(zinb_g, file = 'zinb-genewise-disp-fc2.rda')
load('zinb-genewise-disp-fc2.rda')
counts = simDataIslam$counts
myfct = list(DESeq2 = DESeq2,
edgeR = edgeR,
limmavoom = limma,
MAST = MAST
# NODES = NODES,
# scde = scde,
# metagenomeSeq = metagenomeSeq
)
1
# setwd("/Users/koenvandenberge/Dropbox/phdKoen/singleCell/zinbwaveZingerGithub/zinbwaveZinger/zinbwaveSimulations/islam_sims_fc2/")
knitr::opts_chunk$set(fig.align="center", cache=TRUE, error=FALSE, message=FALSE, warning=TRUE)
library(reticulate)
library(zinbwave)
library(BiocParallel)
library(doParallel)
library(Biobase)
library(edgeR)
library(scales)
library(DESeq2)
library(iCOBRA) # roc
library(limma)
library(genefilter) #filtered pvalues
library(MAST)
library(RColorBrewer)
library(knitr)
library(ggplot2)
library(cowplot)
# use new simulation.
#library(zingeR)
# pathToParentFolder="~/Dropbox/phdKoen/singleCell/zinbwavezingerGitHub/zinbwaveZinger/"
source("../../zingeRsimulationFunctions/simulationHelpFunctions_v7_diffInZero.R")
knitr::knit_engines$set(python = reticulate::eng_python)
reticulate::py_available(TRUE)
# bug in rstudio/reticulate:
matplotlib <- import("matplotlib")
matplotlib$use("Agg", force = TRUE)
NCORES <- 8
registerDoParallel(NCORES)
register(DoparParam())
#code from https://github.com/statOmics/zingeR/blob/master/vignettes/zingeRVignette_v2.Rmd
data(islamEset, package = "zingeR")
islamHlp=exprs(islamEset)[9:nrow(exprs(islamEset)),] #first 8 are spike-ins.
cellType=pData(islamEset)[,"cellType"]
# paramsIslam = getDatasetMoMPositive(counts = islamHlp)
# save(paramsIslam, file="./paramsIslam.rda")
load("./paramsIslam.rda")
nSamples=80
grp=as.factor(rep(0:1, each = nSamples/2)) #two-group comparison
nTags=10000 #nr of features
set.seed(11)
DEind = sample(1:nTags,floor(nTags*.1),replace=FALSE) #10% DE
fcSim=(2 + rexp(length(DEind), rate = 1/2)) #fold changes
libSizes=sample(colSums(islamHlp),nSamples,replace=TRUE) #library sizes
simDataIslam <- NBsimSingleCell(foldDiff = fcSim, ind = DEind,
dataset = islamHlp, nTags = nTags,
group = grp,
verbose = TRUE, params = paramsIslam,
lib.size = libSizes, normalizeLambda=TRUE)
simDataIslam$counts[1:5,1:5]
# BCV plots
dOrig=suppressWarnings(edgeR::calcNormFactors(DGEList(islamHlp)))
dOrig=estimateGLMTagwiseDisp(estimateGLMCommonDisp(dOrig, design=model.matrix(~cellType), interval=c(0,10)),prior.df=0)
d=suppressWarnings(edgeR::calcNormFactors(DGEList(simDataIslam$counts)))
d=estimateGLMTagwiseDisp(estimateGLMCommonDisp(d, design=model.matrix(~grp), interval=c(0,10)),prior.df=0)
par(mfrow=c(1,2))
plotBCV(dOrig,ylim=c(0,13), xlim=c(2,16), main="real dataset")
plotBCV(d,ylim=c(0,13), xlim=c(2,16), main="simulated dataset")
par(mfrow=c(1,1))
# association of library size with zeros
plot(x=colSums(islamHlp), y=colMeans(islamHlp==0), xlab="Log library size", ylab="Fraction of zeros", ylim=c(0.2,1))
points(x=colSums(simDataIslam$counts), y=colMeans(simDataIslam$counts==0), col=2)
legend("bottomleft", c("real", "simulated"), col=1:2, pch=1)
# association of aveLogCPM with zeros
plot(x=edgeR::aveLogCPM(islamHlp), y=rowMeans(islamHlp==0), xlab="Average log CPM", ylab="Fraction of zeros", ylim=c(0,1), col=alpha(1,1/2), pch=19, cex=.3)
points(x=edgeR::aveLogCPM(simDataIslam$counts), y=rowMeans(simDataIslam$counts==0),col=alpha(2,1/2),pch=19,cex=.3)
legend("bottomleft", c("real", "simulated"), col=1:2, pch=16)
edgeR <- function(counts, group, ylim = NULL, xlim = NULL){
d <- DGEList(counts)
d <- suppressWarnings(edgeR::calcNormFactors(d))
design <- model.matrix(~group)
d <- estimateDisp(d, design)
plotBCV(d, ylim = ylim, main = 'edgeR', xlim = xlim)
fit <- glmFit(d,design)
lrt <- glmLRT(fit, coef = 2)
pval <- lrt$table$PValue
padj <- p.adjust(pval, "BH")
cbind(pval = pval, padj = padj)
}
DESeq2 <- function(counts, group, ylim = NULL, xlim = NULL){
colData <- data.frame(group = group)
dse <- DESeqDataSetFromMatrix(countData=counts, colData=colData, design=~group)
colData(dse)$group <- as.factor(colData(dse)$group)
dse <- DESeq2::estimateSizeFactors(dse, type="poscounts")
dse <- estimateDispersions(dse, minmu=1e-3)
dse <- nbinomWaldTest(dse, minmu=1e-3, betaPrior=TRUE)
rr <- results(dse)
cbind(pval = rr$pvalue, padj = rr$padj)
}
limma <- function(counts, group, ylim = NULL, xlim = NULL){
design <- model.matrix(~ group)
nf <- suppressWarnings(edgeR::calcNormFactors(counts))
y <- voom(counts, design, plot = FALSE, lib.size = colSums(counts) * nf)
fit <- lmFit(y, design)
fit <- eBayes(fit)
tt <- topTable(fit, coef = 2, n = nrow(counts), sort.by = "none")
pval <- tt$P.Value
padj <- tt$adj.P.Val
cbind(pval = pval, padj = padj)
}
scde <- function(counts, group, ylim=NULL, xlim=NULL){
counts = matrix(as.integer(counts),nrow=nrow(counts),ncol=ncol(counts))
if(is.null(colnames(counts))) colnames(counts)=paste0("sample",1:ncol(counts))
require(scde)
# calculate error models
o.ifm <- scde.error.models(counts = counts, groups = group, n.cores = 1, threshold.segmentation = TRUE, save.crossfit.plots = FALSE, save.model.plots = FALSE, verbose = 0)
# estimate gene expression prior
o.prior <- scde.expression.prior(models = o.ifm, counts = counts, length.out = 400, show.plot = FALSE)
# calculate differential expression
ediff <- scde.expression.difference(o.ifm, counts, o.prior, groups  =  group, n.randomizations  =  150, n.cores  =  1, verbose  =  0)
lfc <- ediff$mle
pval=(1-pnorm(abs(ediff$Z)))*2
padj=(1-pnorm(abs(ediff$cZ)))*2
out = cbind(pval,padj,lfc)
return(out)
}
### copied code from FPR_mocks.Rmd on September 14, 2017.
MAST <- function(counts, group, ylim = NULL, xlim = NULL){
require(MAST)
tpm <- counts*1e6/colSums(counts)
tpm <- log2(tpm+1)
sca <- FromMatrix(tpm,  cData=data.frame(group=group))
#sca <- FromMatrix(counts,  cData=data.frame(group=group))
# Adaptive thresholding from MAST vignette
freq_expressed <- 0.2
thres <- thresholdSCRNACountMatrix(assay(sca), nbins = 10, min_per_bin = 50, conditions = group)
#par(mfrow=c(5,4))
#plot(thres)
assays(sca) <- list(thresh=thres$counts_threshold, tpm=assay(sca))
expressed_genes <- freq(sca) > freq_expressed
sca <- sca[expressed_genes,]
ngeneson <- apply(counts,2,function(x) mean(x>0))
CD <- colData(sca)
CD$ngeneson <- ngeneson
CD$cngeneson <- CD$ngeneson-mean(ngeneson)
colData(sca) <- CD
## differential expression
fit <- zlm(~ cngeneson + group , sca = sca)
lrFit <- lrTest(fit, 'group')
pval <- lrFit[, 'hurdle', 'Pr(>Chisq)']
padj <- p.adjust(pval, method = "BH")
### MAST filtered the genes, so make a list that is consistent with the original count matrix.
pvalAll = vector(length=nrow(counts))
pvalAll[] = 1
names(pvalAll)=rownames(counts)
pvalAll[match(names(pval),names(pvalAll))] = pval
padjAll = vector(length=nrow(counts))
padjAll[] = 1
names(padjAll)=rownames(counts)
padjAll[match(names(padj),names(padjAll))] = padj
out = cbind(pval = pvalAll, padj = padjAll, logfc = NA)
return(out)
}
NODES <- function(counts, group, xlim, ylim){
require(NODES)
g=ifelse(group==0,"A","B")
colnames(counts)=g
normCounts=pQ(counts)
res=NODES::NODES(data=normCounts,group=colnames(normCounts))
pval=vector(length=nrow(counts))
names(pval)=rownames(counts)
pval[rownames(normCounts)]=res$Fisher
pval[is.na(pval)]=1
padj=p.adjust(pval,"BH")
lfc=NA
out=cbind(pval,padj,lfc)
return(out)
}
metagenomeSeq <- function(counts, group, xlim, ylim){
require(metagenomeSeq)
design <- model.matrix(~group)
pheno <- AnnotatedDataFrame(data.frame(group=group))
rownames(pheno) <- colnames(counts)
p <- cumNormStatFast(counts)
dat <- newMRexperiment(counts=counts, phenoData=pheno, featureData = NULL, libSize = colSums(counts), normFactors = metagenomeSeq::calcNormFactors(counts, p=p))
fit <- fitZig(dat,design)
lfc <- fit$eb$coefficients[,"group1"]
pval <- fit$eb$p.value[,"group1"]
padj <- p.adjust(pval)
out <- cbind(pval,padj,lfc)
return(out)
}
Seurat <- function(counts, group, xlim=NULL, ylim=NULL){
require(Seurat)
seur = CreateSeuratObject(counts, project=paste0("cell",as.character(group)), display.progress = FALSE)
res <- FindMarkers(seur, ident.1 = "cell0", ident.2 = "cell1", print.bar=FALSE)
pval = res$p_val[match(rownames(counts),rownames(res))]
padj = p.adjust(pval,"BH")
out=cbind(pval,padj)
return(out)
}
#https://github.com/miaozhun/DEsingle downloaded on November 20, 2017
DEsingle <- function(counts, group, xlim=NULL, ylim=NULL){
require(DEsingle)
res = DEsingle(counts=counts, group=group)
pval = res[,"pvalue"]
padj = res[,"pvalue.adj.FDR"]
out=cbind(pval,padj)
return(out)
}
zingeR_edgeR <- function(counts, group, ylim = NULL, xlim = NULL){
#require(zingeR)
d <- DGEList(counts)
d <- suppressWarnings(edgeR::calcNormFactors(d))
design <- model.matrix(~ group)
weights <- zingeR::zeroWeightsLS(counts = d$counts, design = design, maxit = 300,
normalization = "TMM", verbose = F)
d$weights <- weights
d <- estimateDisp(d, design)
plotBCV(d, ylim = ylim, main = 'zingeR', xlim = xlim)
fit <- glmFit(d,design)
lrt <- zinbwave::glmWeightedF(fit, coef = 2, independentFiltering = TRUE)
cbind(pval = lrt$table$PValue, padj =lrt$table$padjFilter)
}
zingeR_DESeq2 <- function(counts, group, ylim = NULL, xlim = NULL){
#require(zingeR)
colData <- data.frame(group = group)
design <- model.matrix(~ group)
dse <- DESeqDataSetFromMatrix(countData = counts, colData = colData,
design = ~group)
weights <- zingeR::zeroWeightsLS(counts = counts, design = design, maxit = 300,
normalization = "DESeq2_poscounts", colData = colData,
designFormula = ~group, verbose = F)
assays(dse)[["weights"]] <- weights
dse <- DESeq2::estimateSizeFactors(dse, type="poscounts")
dse <- estimateDispersions(dse)
dse <- nbinomWaldTest(dse, betaPrior = TRUE, useT = TRUE,
df = rowSums(weights) - 2)
rr <- results(dse)
cbind(pval = rr$pvalue, padj = rr$padj)
}
zinbwave_edgeR <- function(counts, group, zinb, ylim = NULL, xlim = NULL, main = 'ZINB-WaVE'){
d=DGEList(counts)
d=suppressWarnings(edgeR::calcNormFactors(d))
design=model.matrix(~group)
weights <- computeObservationalWeights(zinb, d$counts)
d$weights <- weights
d=estimateDisp(d, design)
plotBCV(d, ylim = ylim, main = main)
fit=glmFit(d,design)
lrt=glmWeightedF(fit,coef=2, independentFiltering = TRUE)
cbind(pval = lrt$table$PValue, padj =lrt$table$padjFilter)
}
zinbwave_DESeq2 <- function(counts, group, zinb){
colData=data.frame(group=group)
design=model.matrix(~group)
dse=DESeqDataSetFromMatrix(countData=counts, colData=colData, design=~group)
weights <- computeObservationalWeights(zinb, counts(dse))
assays(dse)[["weights"]]=weights
dse = DESeq2::estimateSizeFactors(dse, type="poscounts")
dse = estimateDispersions(dse, minmu=1e-3)
dse <- nbinomWaldTest(dse, minmu=1e-3, betaPrior=TRUE, useT=TRUE, df=rowSums(weights)-2)
res = results(dse)
cbind(pval = res$pvalue, padj = res$padj)
}
zinbwave_limma <- function(counts, group, zinb){
design <- model.matrix(~group)
nf <- edgeR::calcNormFactors(counts)
zeroWeights <- computeObservationalWeights(zinb, counts)
y <- voom(counts, design, plot=FALSE, lib.size = colSums(counts)*nf,
weights = zeroWeights)
y$weights <- y$weights * zeroWeights
fit <- lmFit(y, design, weights=y$weights)
fit$df.residual <- rowSums(zeroWeights) - ncol(design)
fit <- eBayes(fit)
tt <- topTable(fit,coef=2,n=nrow(counts), sort.by = "none")
pval <- tt$P.Value
baseMean = unname(rowMeans(sweep(counts,2,nf,FUN="*")))
hlp <- pvalueAdjustment_kvdb(baseMean=baseMean, pValue=pval)
padj <- hlp$padj
cbind(pval = pval, padj = padj)
}
diffxpy_wald = function(counts, group, ylim = NULL, xlim=NULL) {
res = py$wald_test(counts, group)
}
core <- SummarizedExperiment(simDataIslam$counts,
colData = data.frame(grp = grp))
# zinb_c <- zinbFit(core, X = '~ grp', commondispersion = TRUE, epsilon=1e12)
# save(zinb_c, file = 'zinb-common-disp-fc2-eps12.rda')
load('zinb-common-disp-fc2-eps12.rda')
# zinb_g <- zinbFit(core, X = '~ grp', commondispersion = FALSE, epsilon=1e12)
# save(zinb_g, file = 'zinb-genewise-disp-fc2.rda')
load('zinb-genewise-disp-fc2.rda')
counts = simDataIslam$counts
myfct = list(DESeq2 = DESeq2,
edgeR = edgeR,
limmavoom = limma,
MAST = MAST
# NODES = NODES,
# scde = scde,
# metagenomeSeq = metagenomeSeq
)
# if we additionally load Seurat, too many packages are loaded and the DLL limit is reached. We ran Seurat in a separate session and will add it in this session.
par(mfrow = c(2,2))
ylim = c(0, 11)
xlim = c(0, 16)
res = lapply(names(myfct), function(fname){
fct = myfct[[fname]]
message(paste0("running ", fname))
fct(counts = counts, group = grp, ylim = ylim, xlim = xlim)
})
counts = simDataIslam$counts
myfct = list(DESeq2 = DESeq2,
edgeR = edgeR,
limmavoom = limma,
MAST = MAST
# NODES = NODES,
# scde = scde,
# metagenomeSeq = metagenomeSeq
)
# if we additionally load Seurat, too many packages are loaded and the DLL limit is reached. We ran Seurat in a separate session and will add it in this session.
par(mfrow = c(2,2))
ylim = c(0, 11)
xlim = c(0, 16)
res = lapply(names(myfct), function(fname){
fct = myfct[[fname]]
message(paste0("running ", fname))
fct(counts = counts, group = grp, ylim = ylim, xlim = xlim)
})
# load("seuratResIslam.rda")
# res[[8]] = seuratRes
# names(res)[8] = "Seurat"
#res[['ZINB-WaVE_DESeq2_common']] = zinbwave_DESeq2(counts, grp, zinb_c)
res[['ZINB-WaVE_edgeR_common']]  = zinbwave_edgeR(counts, grp, zinb_c, ylim=ylim, main = 'ZINB-WaVE, common dispersion', xlim = xlim)
#res[['ZINB-WaVE_limmavoom_common']]  = zinbwave_limma(counts, grp, zinb_c)
#res[['ZINB-WaVE_DESeq2_genewise']] = zinbwave_DESeq2(counts, grp, zinb_g)
#res[['ZINB-WaVE_edgeR_genewise']]  = zinbwave_edgeR(counts, grp, zinb_g, ylim=ylim, main = 'ZINB-WaVE, genewise dispersion', xlim = xlim)
#res[['ZINB-WaVE_limmavoom_genewise']]  = zinbwave_limma(counts, grp, zinb_g)
#par(mfrow = c(1,1))
res[["zingeR_edgeR"]] = zingeR_edgeR(counts=simDataIslam$counts, group=grp)
#res[["zingeR_DESeq2"]] = zingeR_DESeq2(counts=simDataIslam$counts, group=grp)
save(res, file="./intermediate_res.rda")
load("./intermediate_res.rda")
tmp_res_lrt = diffxpy_wald(counts=simDataIslam$counts, group=grp)
simDataIslam$counts
repl_python()
